[07:54] <Jetrel> okay, yeah, there was a change in testing where the "anchors" - the secret hidden objects that make crates and such respawn were made visible for a bit, but that's gone now.
[07:54] <Jetrel> They appear to work correctly on my machine.


[14:29] <Fei-FW> Player and enemies are slowed down while underwater. Is there a way to control this? For example make creatures walk in water freely like on the ground?
[14:29] <Sirp> Fei-FW: yes, in the level file there are settings air_resistance and water_resistance
[14:30] <Jetrel> Fei-FW:  Sirp should correct me if I'm wrong on this, since we "did it once and didn't have to alter it much", but ... yes, there's the part he described.
[14:30] <Sirp> which control the amount of resistance air and water have on objects. Defaults are 20 for air and 100 for water
[14:30] <Sirp> so you can do that
[14:30] <Sirp> as for making them walk freely in water, yes absolutely, there's nothing in the engine that inherently causes "swimming" behavior in water -- that's all in how you script objects
[14:30] <Jetrel> Fei-FW:  also, the reason creatures in frogatto don't sink, is because they *force* themselves into a specific set of animations the moment they enter water, and those animations are set to have no accel_y
[14:31] <Jetrel> Fei-FW:  I should say specifically, they are set to have "accel_y: 0".  This makes them lose their gravity in water.
[14:31] <Jetrel> They continue to have the same velocity they had before, but this velocity wanes quickly due to that "resistance in water" Sirp mentioned.
[14:34] <Fei-FW> Sirp: level file there are settings air_resistance and water_resistance <-- Oh I see. But I also want to only enemies walk freely and player slow because water is their living space and player just a human uncomfortable in the water. Can I make a distinction?
[14:35] <Jetrel> Fei-FW:  you can - individual creatures can be given values that correspond to this.
[14:36] <Fei-FW> Jetrel: Great! Thanks a lot! :)
[14:36] <Jetrel> Fei-FW:  we have two things:
[14:37] <Jetrel> Fei-FW:  we have "traction_in_#whatever the medium_is#" and then "friction"
[14:37] <Jetrel> Fei-FW:  friction is global and is the same for all mediums.  It makes their velocity slow down.
[14:38] <Jetrel> Traction is different for each medium, and the way the calculation works, IIRC, is that it's multiplied (as if 1000 = 100%) against their acceleration.
[14:39] <Jetrel> So e.g. traction_in_water: 2000 would make the same walking animation accelerate twice as fast if they had traction:1000 as their normal value (traction is just shorthand for "traction on land" - we don't have a special ending to the name)
[14:40] <Jetrel> so if you had a green "swamp man", he would then accelerate 2x as fast when submerged.
[14:41] <Jetrel> I think being submerged is calculated by the top point of something's solid area being under the water-line; some flexibility on this would be nice to have.
[14:42] <Jetrel> Since I can see it being a *very* real use-case that people would want creatures only half-submerged to change their movement properties.
[14:42] <Jetrel> Fei-FW:  traction_in_air is the other property;  it kicks in when something's feet aren't touching a solid tile.
[14:43] <Fei-FW> I had "swamp mans" walking slow half submerged and player too.
[14:45] <Fei-FW> Jetrel: Ah yes, Now I remember dealing with something like this in jump air control.
[14:45] <Jetrel> Fei-FW: the idea is to have creatures - frogatto himself being a prime example, who can accelerate great on land, but who have little/no control when in the air.


[13:39] <Jetrel> Sirp:  we seem to have a little "possible duplication of purpose" in a certain frogatto event:  we've got on_surface_damage and on_collide_damage
[13:40] <Jetrel> I don't know which is intended to be "live", right now.
[13:42] <Jetrel> Sirp:  well, this is kinda ancient code I didn't write - These deal with the player taking damage from "harmful tiles".
[13:43] <Jetrel> I don't quite understand why we have ... two, though.
[13:43] <Jetrel> Sirp:  the only change that's happened to these since strict mode is I put an arg in front of the surface_damage, in a quick-and-dirty attempt to fix it.
[13:44] <Jetrel> So we've got:  on_surface_damage: "fire_event('collide_damage')",
[13:44] <Jetrel> on_collide_damage: "if(not is_invincible, [
[13:44] <Jetrel> 	add(hitpoints, dmg), blah, blah
[13:44] <Jetrel> ] where dmg = arg.surface_damage)",
[13:45] <Jetrel> It says I'm doing "illegal object access" on the surface_damage;  loosely I know what that means, but not specifically.
[13:46] <Sirp> Jetrel: what error message are you getting exactly?
[13:46] <Jetrel> I'm not sure if it means I'm accessing something that's not a valid symbol, or something that's a valid symbol but isn't accessible in this context
[13:49] <Sirp> Jetrel: okay so what I'll do is make it so on_surface_damage gets arg.surface_damage defined
[13:49] <Sirp> then when you fire the event you should pass that along
[13:49] <Sirp> fire_event('collide_damage', {surface_damage: arg.surface_damage})
[13:49] <Sirp> or we can just obsolete surface_damage as an event, possibly
[13:49] <Jetrel> How again do I do that?  I'm ... oh, okay, that's exactly what I'd just tried. :D
[13:50] <Sirp> and just have collide_damage
[13:50] <Jetrel> Well, yeah - what IS the difference between the two?
[13:50] <Sirp> yeah but it won't work until I add surface_damage
[13:50] <Sirp> the difference is that on_collide_damage is fired when you *collide* with something that has a damage attribute
[13:50] <Sirp> surface_damage is fired when you end up standing on something that has a damage attribute (even if it's not a collision, such as when you walk out onto it)
[13:51] <Jetrel> Ahhhh
[13:51] <Sirp> I'm not sure if surface_damage is really needed though
[13:51] <Sirp> maybe just firing on_collide_damage in both cases is the best approach
[13:51] <Jetrel> I'm ambivalent.
[13:52] <Jetrel> So long as I comment in the distinction, it's fine to have something that doesn't make a lot of difference for frogatto-in-particular.
[13:52] <Jetrel> But if you want to simplify it, that's cool - I can't speculate up a prospective use for that in a different game.
[13:52] <irker485> anura-engine: David White anura:master a333ee377da0 / src/custom_object.cpp: deprecated on_surface_damage in favor of on_collide_damage http://git.io/yThfbw
[13:52] <Sirp> Jetrel: there, try that. You should be able to just remove on_surface_damage
[13:53] <Sirp> on_collide_damage will be fired by the engine where itw as being fired
[13:54] <Jetrel> Okay.
[13:54] <Jetrel> Sirp:  surface_damage remains the argument name?
[13:56] <Sirp> Jetrel: yes
[13:56] <Jetrel> great


[08:46] <Jetrel> ActionJackalope:  no, the current hurt sound is _not_ the sound of the character getting wounded (like the physical sound of their body-material being damaged).  It used to be a while back - that used to be the only concept we had.
[08:46] <ActionJackalope> Oh.  So it's supposed to be a bfxr simulation of a vocal?
[08:47] <Jetrel> ActionJackalope:  now, however, we have two separate concepts - a sound for the creature's tissue itself taking damage (what we use for the damage types), and then a sound of the character itself vocalizing - like, squeaking in pain.
[08:47] <Jetrel> ActionJackalope:  yeah, it was always kinda intended as that - I made it myself, but the current one we have is *really* 8-bit ish, and doesn't have much vocal tone to it.


Restructured the logic on player damage responses so that players don't have to re-implement handle_damage, and instead just have a player-tier, and then a character-specific tier of handlers which are automatically called.
https://github.com/frogatto/frogatto/commit/97028f6869df2f1d0c117724edbb0bf80e5b812f


[05:08] <KristaS> and modules/data/icons.cfg
[05:09] <DDR> And: Oh, cool, we have definitions! How would one use them? They can't be just for reference.
[05:10] <KristaS> get_document() should work
[05:10] <DDR> :|
[05:11] <DDR> Took me a moment.
[05:12] <KristaS> Though the file could probably be formatted as a map with the id as the key.
[05:21] <DDR> KristaS: There, at least something good came of this all.
[05:24] <KristaS> okay.
[05:24] <KristaS> should be easy to use with get_document() now.


[16:15] <Jetrel> I also suspect we'll need to keep level_controllers non-strict, or we'll essentially need to come up with some way to "cheat out of" the strict-mode requirement of "every variable must be named", for just doing random variable storage in them.
[16:16] <Jetrel> i.e. {string -> any}
[16:16] <Jetrel> Because that is really something they tend to get used for - I'd overwhelmingly opt for the latter, since strict mode would afford them a ton of benefits besides that.
[16:17] <Jetrel> Plus we'd then actually be able to axe vars forever, etc.
[16:18] <Sirp> Jetrel: I'd just suggest having a property called 'flags' or something which is a {string -> any}
[16:18] * Jetrel nods.
[16:18] <Jetrel> Yup, sounds like it'd do the trick.


[17:24] <Jetrel> Sirp:  our ants in nene's basement rely on custom events, written in the level file, to fire when they die and take care of the whole business of setting the event.
[17:25] <Jetrel> Sirp:  but with the new system now, we of course lose all such events because we create an entirely new object.
[17:32] <Sirp> Jetrel: well you can transfer custom event handlers over. They are held in the event_handlers variable.
[17:32] <Jetrel> okay
[17:32] <Jetrel> Sirp:  is this limited to *just* the ones that either:
[17:33] <Jetrel> 1] manually get set via set(event_handlers, 'expression as a string')
[17:33] <Jetrel> 2] get written into a level file
[17:33] <Jetrel> -fin-
[17:37] <Sirp> Jetrel: yes.
[17:37] <Jetrel> sweet.
[17:37] <Jetrel> I'm gonna try this.
[17:38] <Sirp> so e.g. set(event_handlers.process, "debug('hello')")
[17:51] <Jetrel> hmm, having some trouble with this...  testing something...
[17:54] <Jetrel> Sirp:  hmm, I've been trying to do that via the property map.
[17:58] <Jetrel> Sirp:  yeah, it doesn't seem to work.
[17:59] <Jetrel> Sirp:  want me to commit a test case?
[17:59] * Jetrel assumes yes
[18:00] <irker460> frogatto: Richard Kettering frogatto:master 51d8d9204167 / data/ (level/Seaside/nenes-basement.cfg objects/playable/frogatto_playable.cfg): Test case for one of the ants in nenes-basement getting events passed along. http://git.io/_JIA8w
[18:06] <Jetrel> Sirp:  so basically I have an on_process event for the ant up on the ledge which is a simple "debug(cycle)", and it tries to do both methods for copying it from the "collide_obj" prior to the swallow, into the "throwable_obj" after the swallow.  If it had been copied, one should see a new set of numbers get debugged afterwards
[18:08] <Jetrel> Okay, I just tested the other properties, and they are, indeed, being copied over correctly (e.g. hitpoints) - Just sanity-checked that we weren't "failing to copy anything".
 ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓
[15:00] <Jetrel> Sirp:  so I still have that problem I mentioned last night after you headed to bed.
[15:00] <Jetrel> Sirp: setting event_handlers doesn't seem to work - I've uploaded a test case in nene's-basement
[15:01] <Jetrel> Sirp:  there's an ant in the upper-right ledge which now has on_process: "debug(cycle)".
[15:02] <Jetrel> Sirp:  inside frogatto_playable.cfg:1963, there's a line of code to copy over the event_handlers - there's another line on 1964; neither is working.
[15:02] <Jetrel> Sirp:  so one you swallow the ant, those don't get copied over to the throwable version
[15:03] <DDR> Jetrel: Don't you just set 'process'?
[15:03] <DDR> Instead of 'on_process'?
[15:04] <Jetrel> DDR:  I'm setting neither - I'm doing set(event_handlers, source_object.event_handlers) - copying the entire block from one to the other.
[15:04] <Jetrel> As sirp suggested.
[15:26] <Sirp> Jetrel: yeah you can't ocpy the entire event_handlers. You have to copy specific events.
[15:27] <Jetrel> Sirp:  Well, that kinda stinks, because then that requires foreknowledge, on the level-creator's part, of which events will be copied, and which won't.
[15:29] <Sirp> yeah so need way to enumerate events
[15:35] <Sirp> Jetrel: actually what the heck, I'll just allow wholesale assignment like you're doing now
[15:36] <Jetrel> Nice.
[15:36] <Sirp> Jetrel: okay your code should work now


[11:20] <Jetrel> The goal is that all sounds will consult a global lookup table where, according to the name of the sound, they pick a certain function for attenuation.
[11:26] <Sirp> Jetrel: I'm afraid I'm confused what you mean by 'using a string'? You mean it looks up the function in a map using a string as a key?
[11:27] <Jetrel> Sirp:  it composes the function name on the fly using a string
[11:27] <Jetrel> where preset_function = _sound_defaults[sound_file] and me['_attenuate_' + _sound_defaults[sound_file]['distance_attenuation_function']]",
[11:27] <Jetrel> and such a member would be:  distance_attenuation_function: 'linearly',
[11:39] <Sirp> Jetrel: so it's likely there's a better way to do things. I'd have to look at your code in detail though to understand. In the mean time you can just go if(preset_function is function(int,int) -> int, ...
[11:39] <Sirp> for instance
[11:39] <Sirp> whatever the function signature you have is.
[11:39] <Jetrel> ahhh, wonderful
[11:40] <Sirp> you could also typedef the function signature in types.cfg
[11:50] <Jetrel> yeah, that seems to have gotten me past that issue.


[17:55] <Jetrel> Sirp:  /Users/richard_kettering/Public/anura/src/formula.cpp:1128 ASSERTION FAILED: FUNCTION CALL ON EXPRESSION WHICH ISN'T GUARANTEED TO BE A FUNCTION: any AT At modules/frogatto/data/objects/enemies/experimental/gazer_grey.cfg 92:
[17:55] <Jetrel> _mdistort.stop_process(me),
[17:55] <Jetrel> ^-------------------------^
[17:55] <Jetrel> 	_mdistort: { type: "object", init: "construct('motion_distort')", persistent: false },
[17:55] <Jetrel> It's a library, but how can I "give it type" so that anura's aware of what's in it.
[01:28] <Sirp> Jetrel: do you mean that motion_distort is a class?
[01:28] <Sirp> Jetrel: you'd just make it of type class motion_distort
[01:28] <Sirp> if you're using it as a library I'm not sure why you need this _mdistort variable? Just use lib.motion_distort ? Or does it actually hold state?


[17:32] <DDR> Jetrel: OK, how do I initialize private properties from a spawn command? ASSERT FAIL: src/custom_object_functions.cpp:1209 ASSERTION FAILED: Illegal spawn of moth_small property _desired_height requires initialization
[17:33] <Jetrel> DDR:  uhm, you should be able to do them via a replacement for the 4th parameter.
[17:33] <DDR> OK.
[17:33] <Jetrel> Instead of facing, you'd have {_private_property:  foobar})
[17:33] <DDR> But I need that to set always_active.
[17:34] <Jetrel> Yeah, apparently there's some sort of support for kinda-sorta-but-not-really this in the 5th parameter as well.
[17:35] <DDR> It seems weird to specify a property as private and then have to access it.
[17:39] <Jetrel> DDR:  it can't be set(), is the thing.
[17:40] <Jetrel> Initialized?  sure.  Set at whenever time, no.
[17:42] <Sirp> yeah a private property can be initialized when you create the object
[17:42] <Sirp> I agree slightly weird. Just slightly
[17:42] <DDR> hahaha


[16:26] <DDR> "on_interact": "if( (not level.player.get_stored_event('moth_boss_fight_won')),
[16:26] <DDR>     [swallow_event(), level.player.scripted_move_to_x(988, 1, fire_event(me, 'script1'))]) asserting level.player is obj frogatto_playable",
[16:26] <DDR> Why doesn't that change the error message about the type of level.player not having scripted_move_to_x?
[16:26] <Jetrel_> I don't know - that's a Sirp question.
[16:27] <Jetrel_> That function is in player_controlled_platformer_character
[16:27] <Jetrel_> so it definitely should have it - check and see if the function is actually "for real" there, and not commented out or something.


[18:18] <DDR> Oh, *that* mdistort!
[18:18] <DDR> Uh, the ideal was that it would be a somewhat fire-and-forget way to add an axial motion distort to enemies.
[18:19] <DDR> Or, really, any objects.
[18:19] <Jetrel_> right, and didn't dave do some thing where you could store the associated variables for that within a library?
[18:19] <DDR> I think it's a lib. It's been a bit.
[18:20] <Jetrel_> okay, I'd like to polish that into a real unit.  If you could page in that knowledge that'd be cool.
[18:20] <DDR> Anyway, you instantiate a new version of the library, then I think you have to hook it in to a few places, and you're good to go.
[18:21] <DDR> it's in lib2d/data/classes/motion_distort.
[18:21] <DDR> The class itself is probably already strict.
[18:22] <DDR> Or almost strict?
[18:22] <Jetrel_> because I notice you're setting vars related to it, and it doesn't run right now.
[18:23] <Jetrel_> in the object, I mean
[18:23] <DDR> The way it *worked* was that you created a local copy for the object, then called process() to update the motion distort based on where the object was.
[18:24] <DDR> You could call stop_process if you wanted to remove the effect, say, if you wanted to use custom_draw for other things. It just zeros out the distortion matrix.
[18:25] <DDR> I had a brick on a test level set to do this, but I'd be highly surprised if it were still around.
[18:26] <DDR> test2.cfg
[18:28] <DDR> Jetrel:             on_create: "set(self.vars.mdistort, construct('motion_distort'))",
[18:28] <DDR>             on_process: "[
[18:28] <DDR>                 mdistort.process(me),
[18:28] <DDR>                 set(mid_xy, zip(level.player.ctrl_mice[0], level.camera_position[0:2], a+b)),
[18:28] <DDR>             ]",
[18:29] <DDR> That's test2.cfg, 167, btw, Jetrel.
[18:29] <Jetrel_> DDR:  construct has to be namespaced - where is it from?
[18:50] <Jetrel_> DDR:  again, I ask - what is "construct"?
[18:50] <Jetrel_> 	set(self.vars.mdistort, construct('motion_distort')),
[18:50] <DDR> Also, sorry, totally missed you the first time.
[18:50] <Jetrel_> I can't find it anywhere.
[18:50] <DDR> You have to "construct" a new edition of the library, so that the local variables don't get overwritten when you use the library a second time.
[18:51] <Jetrel_> DDR:  so that's a built-in, then?
[18:51] <DDR> Yeah.
[18:51] <Jetrel_> .... okay
[18:51] <DDR> The motion distortion library uses a few _private_variables, which need to be different for each object it's tracking.
[18:52] <DDR> Think of it like new whatever() in Javascript. A bit, at least.
[18:56] <DDR> Right. Just assign it to a storage-backed property, then?
[18:58] <Jetrel_> DDR:  ... okay.
https://github.com/frogatto/frogatto/commit/6aa43f68d6503dea461f22649963cdab6670698f


[15:51] <Jetrel_> Also, I'm finding that "map for the 4th parameter to object/spawn" to be really a nice convenience.


[19:14] <Jetrel> Sirp:  formula_function.cpp:3771 ASSERTION FAILED: Function call argument 4 does not match. Function expects bool provided string At modules/frogatto/data/objects/effects/control/text_controller.cfg 33:
[19:14] <Jetrel> text(txt, font, size, align)
[19:15] <Jetrel> Sirp:  align is a string of the set: ["left", "center", "right"] - not a bool.


[17:13] <Jetrel> Sirp:  is there a value one can query to tell if an object is attached to a level?
[17:15] <Sirp> Jetrel: no, you can just look for it in the level's list of objects
[17:15] <Jetrel> Okay.


[16:46] <Jetrel> Hmm, so I'm thinking the problem with the anthills is that because objects are no longer changing type, the stored references to the ants become hanging refs after they're swallowed.
[16:47] <Jetrel> Anthills are one of the few spawners that - rather than filtering level.chars for spawned mooks in a certain rectangular box, they instead add them to a list after spawning them.
[16:47] <Jetrel> So I expect it goes like:
[16:47] <Jetrel> 1] child spawned, ref added to anthill's list
[16:48] <Jetrel> 2] child swallowed.  Object removed by frogatto, but not deleted since the ref persists.
[16:49] <Jetrel> 3] frogatto replaces the child with a brand-new object..  but the brand-new object is no longer tracked by the anthill.  Instead the anthill is tracking the old object, which is now in limbo, no longer connected to the level.
[16:50] * Jetrel muses on this.


[12:30] <DDR> Jetrel: OK, so having given some thoughts to the basement-ant problem...
[12:31] <Jetrel> k
[12:31] <DDR> How in the world do we track if the ants have been killed?
[12:31] <Jetrel> A stored event, same as everything else.
[12:33] <DDR> Right, but how do I store the event?
[12:33] <Jetrel> level.player.store_event('foobar_happened', 1),  if memory serves
[12:34] <DDR> Well, yeah, that's the easy part.
[12:34] <Jetrel> yup
[12:34] <DDR> But how do I store the _event_ that that resides in?
[12:34] <Jetrel> You give the object an on_die:  "level.player.store_event('foobar_happened', 1)" event in the level.
[12:35] <Jetrel> Now, this is utterly broken by a change we've recently made:
[12:35] <DDR> Like, we don't store objects in Frogatto anymore, so if he kills the ants outside of the basement (or if he swallows them at all?) the object events are gone?
[12:35] <Jetrel> The moment frogatto even swallows the ant, the object events are gone.
[12:35] <Jetrel> This is a problem, and we need to figure out a general solution.
[12:35] * DDR nods
[12:36] <Jetrel> If there was a nice list of custom object events we could query, being able to query them and restore them would be pretty straightforward.
[12:36] <DDR> Yes.


[08:35] <Sirp> DDR / Jetrel_: okay so the problem when you go to the load door is just that the formula is rather messed up
[08:36] <Sirp> and strict mode is detecting the error
[08:40] <Sirp> DDR / Jetrel_: If you look in titlescreen.cfg, it goes set(child.event_handlers.enter_level, q( ...some formula... ))
[08:40] <Sirp> the issue is 'some formula' has strings that include ${...} expressions in them.
[08:40] <Sirp> the issue is that the ${...} expressions are going to get expanded at the time the outter q(...) string is parsed, NOT in the inner '...' string.
[08:41] <Sirp> and at the q(...) time, the identifiers they reference aren't valid.
[08:41] <Sirp> so, have to fix that. But then the q(...) formula is invalid in a number of other ways (mis-matched parens) and I can't immediately tell the intent to fix it.
[08:41] <Sirp> it might be good to have an FFL syntax for a 'literal' string though
[08:41] <Sirp> which doesn't do ${...} expansion
[09:05] <DDR> D'OH. xD
[09:05] <DDR> Sirp: What the formula is suppose to do, as far as I can tell, is set some text objects based on the properties of the saved levels.
[09:06] <DDR> It use to be in an event handler in menu_selector_load_level, but that object was horribly out-of-date compared to menu_selector.
[09:08] <DDR> The only difference that mattered, were two event handlers. Normally, this would go in the level file, and be a custom event of that object. But, here, since we have to create the object dynamically, we have to set the events in the level file that contains the object creating the menu_selector.
[09:13] <Sirp> DDR: beats me what it's meant to do
[09:14] <DDR> It's trying to spawn a few objects that tell you what the savegame you are loading is.
[09:14] <DDR> The second event actually loads the game.
[09:18] * Phanterm (~Karasawa@210.165.0.242) Quit
[09:19] <DDR> The way that selector works is that it reads some saved data and spawns the menu items based on that, and then when we select one the finish_menu event is fired.
[09:24] <DDR> Anyway, I removed the ${} interpolation.


[17:22] <DDR> Jetrel, do you know what the star in "on_mouse_down*" means?
[17:22] <Jetrel> No, that seems really.... odd
[17:33] <DDR> I bet it's to match even when the mouse event is outside the object too.
[17:34] <DDR> on_mouse_down -> click *on* object, on_mouse_down* -> click *anywhere*.
[17:34] <DDR> This menu thing is just opening up as a fractal of objects that need proper type handling.
[17:38] <KristaS> DDR: That is a correct interpretation. Though those events should already have type information specified for the args.* parameters
[17:39] <DDR> That's good. Yeah, the event isn't being the problem -- I just found it, and was like 'whut?'
[17:39] <DDR> No Problems Here. :)
[17:45] <DDR> KristaS: Actually, set(xy, zip([int] <- item.xy, cursor_offset, a+b)) needs the cast to [int], where item is object.


[16:56] <Jetrel_laptop> Sirp:  yeah, the next big one I'm tackling is a conversion where we're going to change up all of our levers on the various levels to a new mechanism...  basically we've had this persistence issue, so we're changing over to *mandating* that all gates and so on are always persistent.  They always require you to give them an event.
[16:57] <Jetrel_laptop> We did that for gates, already, prior to 1.3, and it solved a lot of issues.
[16:58] <Jetrel_laptop> So what we're now doing is we're going to switch the "lever" objects over to it as well.  The nice little benefit is this will mean they no longer need to be manually connected to the objects which they trigger.  Instead, they'll just do a quick map(filter(level.chars, value.event = me.event), fire_event(value, 'triggered'))
[17:03] <Jetrel_laptop> Should be good. :)


[17:47] <Jetrel> One quandary I have with this new lever system is, for example:
[17:48] <Jetrel> Fans and platforms - with platforms, it's quite less common, but with fans, it's fairly normal to want to have both "active" and "inactive" as default states prior to the player doing something that is later stored.
[17:48] <Jetrel> Ultimately, the purpose of fans is usually an obstruction, and unlike platforms, where moving almost always gives you new freedom, fans actually can achieve that both ways.
[17:49] <Jetrel> An off fan can need to be turned on to let you reach a high spot.  Or - an on fan can need to be turned off to let you run past it.
[17:50] <Jetrel> So whilst with platforms I've been able to always assume that state-changing ones should be off, and then get turned on, this isn't the case for fans.
[17:51] <Jetrel> ---
[17:51] <Jetrel> So we're trying to get away from having boolean flags in everything.
[17:52] <Jetrel> Since 1] doesn't persist across levels 2] raises some real confusion about precedence if you have boolean flags, and then separately have an event.
[17:53] <Jetrel> I think the way to do this is to have some object (unfortunately this needs to be "one and only one" - probably the lever that controls things), have an optional field for the default state of a certain event.
[17:55] <Jetrel> so if the level starts and the event hasn't been stored in the player set, it'll store this new state, and fire the toggle command to all involved parties...  this does however raise potential problems of walking onto a level, and having something odd happen like a gate suddenly closing.
[17:56] <Jetrel> Alternatively, we could have a list of such events right in frogatto itself - it's very clean to have them all globally listed, but it's nasty in that it breaks "locality of relevant information"
[17:57] <Jetrel> ... yuck, the last option is looking nicest. :(
[17:59] <Jetrel> :|  To be fair, "locality of relevant information" and "don't repeat yourself" are existentially opposed.
[18:01] <Jetrel> hmm
[18:02] <Jetrel> Let's give "in the lever" a try.
...
[18:04] <Jetrel> I have a bad feeling it may be hairy.  There's no way to enforce which order they get processed in, and if it sets the event before dependent items, we'll have to fire the toggle event at them.  (which is to say we always have to because we're blind about that).
...
[18:40] <DDR> Jetrel: Maybe just make the fan itself contain a boolean 'default_on' variable, which defaults to false? Then xor that with the stored event and all that would entail?
[18:40] <DDR> It would mean switches would be flipped with respect to what they did, but whatever. :P
[18:40] <Jetrel> DDR:  right, yeah, the goal is to avoid doing that.
[18:41] <DDR> Ah.
[18:41] <Jetrel> DDR:  the goal is to have these have *no* internal flag storing their value.  It's possible that's a stupid goal
[18:41] <Jetrel> DDR:  in fact...
[18:41] <Jetrel> DDR:  yeah - I think your plan is a much better plan. :)
[18:42] <DDR> It's a worthy goal, but not one that it's worth spending the amount of time that would need spending on it.


[15:14] <Sirp> DDR: you can't really check for the presence or absence of a property
[15:14] <Sirp> we might add a nice way to do this though
[15:15] <DDR> OK. I could add this property to pretty much *all* enemies... <--(NO WAY!!!)
[15:18] <Sirp> DDR: what you should be able to do is create an interface and see if the object matches the interface.
[15:18] <DDR> How do I define an interface, again?
if(value is {boss_hitpoints: decimal}, value.boss_hitpoints, value.hitpoints))
...
[18:43] <Sirp> DDR: so yeah basically there is no way to test "does this property exist in an object?" dynamically
[18:44] <Sirp> what I suggest is having a prototype which defines it and then see if the object is of the type of the prototype
[18:44] <DDR> Sirp: I sort of solved it. if(value is {boss_max_hitpoints: decimal}, value.boss_max_hitpoints, value.max_hitpoints))
[18:45] <DDR> Your tip about the interface was dead on.
[18:45] <DDR> (Uh, this isn't doing anything *nasty* under the hood, is it?)
[18:51] <DDR> Or, say, flat-out not working?
[18:52] <Sirp> DDR: yeah that won't work.
[18:52] <DDR> Curses.
[18:52] <Sirp> DDR: there is no real way to do it dynamically right now.


[18:58] <Jetrel> Essentially what all bosses that need to not be deleted after death SHOULD do, is they should let themselves properly go to zero hp...  then de-register themselves from the "gui's list of active bosses" (making the bar go away), and then give themselves back > 0 hitpoints.
[18:58] <Jetrel> This is what milgram does.
[18:59] * DDR nods.

!!!!!
[10:32] <Jetrel> DDR:  basically there's something broken afoot, where, now, if you try to query level.player for a stored event on the first frame of a level, it comes back null.
[10:40] <Jetrel> Sirp:  seems to be any property, but we've definitely had issues with the get_stored_event(name) property in "player_controlled" (the prototype frogatto inherits from, which is also declared as the player_type in module.cfg).
[10:42] <Sirp> note though that on_create is fired when the level starts and not all objects will be fully created at the point on_create is fired
[10:45] <Jetrel> Sirp:  that, and "on_start_level" get used to have things like gates check the player to determine if their initial state is open or closed, and they've all got special code to avoid visually showing a transition, and just to instantly "set themselves" to the mode that's specified.
[12:05] <Sirp> Jetrel: okay so the problem is the issue with on_create as I mentioned.
[12:05] <Sirp> but I'm thinking maybe we have to revert on_create to just the previous behavior
[12:05] <Sirp> but have a new on_init event
[12:05] <Sirp> which is used to actually initialize objects.
[12:06] <Sirp> and on_init will be different in that access must be quite limited. But can be used to construct initial state.
[12:07] <Sirp> the downside is this kind of proliferation of event types makes things complicated. :(
[12:10] <irker437> anura-engine: David White anura:master e4c57e2f77b7 / src/level.cpp: revert behavior of on_create http://git.io/XnppCA
[12:10] <Sirp> Jetrel: okay should be fixed now
[

[10:35] <DDR> It would just mean, in our case, that we wouldn't need to assign every lever-and-gate combination a variable in Frogatto.
[10:43] <Jetrel> DDR:  in theoretical terms, I agree with that fear, in practical terms, I refuse to change it because we've lived with that system for roughly two years now, and due to how I name events (by always strictly prefixing them with the level name), it will never cause problems.  I agree with what you're saying, but I don't want to overhaul a working system for no gain, especially when I just finished a marathon overhaul.  I also don't want someone else who doesn't have all the danger points just paged into their head, the hard way, do an overhaul.


