[08:35] <Sirp> DDR / Jetrel_: okay so the problem when you go to the load door is just that the formula is rather messed up
[08:36] <Sirp> and strict mode is detecting the error
[08:40] <Sirp> DDR / Jetrel_: If you look in titlescreen.cfg, it goes set(child.event_handlers.enter_level, q( ...some formula... ))
[08:40] <Sirp> the issue is 'some formula' has strings that include ${...} expressions in them.
[08:40] <Sirp> the issue is that the ${...} expressions are going to get expanded at the time the outter q(...) string is parsed, NOT in the inner '...' string.
[08:41] <Sirp> and at the q(...) time, the identifiers they reference aren't valid.
[08:41] <Sirp> so, have to fix that. But then the q(...) formula is invalid in a number of other ways (mis-matched parens) and I can't immediately tell the intent to fix it.
[08:41] <Sirp> it might be good to have an FFL syntax for a 'literal' string though
[08:41] <Sirp> which doesn't do ${...} expansion
[09:05] <DDR> D'OH. xD
[09:05] <DDR> Sirp: What the formula is suppose to do, as far as I can tell, is set some text objects based on the properties of the saved levels.
[09:06] <DDR> It use to be in an event handler in menu_selector_load_level, but that object was horribly out-of-date compared to menu_selector.
[09:08] <DDR> The only difference that mattered, were two event handlers. Normally, this would go in the level file, and be a custom event of that object. But, here, since we have to create the object dynamically, we have to set the events in the level file that contains the object creating the menu_selector.
[09:13] <Sirp> DDR: beats me what it's meant to do
[09:14] <DDR> It's trying to spawn a few objects that tell you what the savegame you are loading is.
[09:14] <DDR> The second event actually loads the game.
[09:18] * Phanterm (~Karasawa@210.165.0.242) Quit
[09:19] <DDR> The way that selector works is that it reads some saved data and spawns the menu items based on that, and then when we select one the finish_menu event is fired.
[09:24] <DDR> Anyway, I removed the ${} interpolation.


[17:22] <DDR> Jetrel, do you know what the star in "on_mouse_down*" means?
[17:22] <Jetrel> No, that seems really.... odd
[17:33] <DDR> I bet it's to match even when the mouse event is outside the object too.
[17:34] <DDR> on_mouse_down -> click *on* object, on_mouse_down* -> click *anywhere*.
[17:34] <DDR> This menu thing is just opening up as a fractal of objects that need proper type handling.
[17:38] <KristaS> DDR: That is a correct interpretation. Though those events should already have type information specified for the args.* parameters
[17:39] <DDR> That's good. Yeah, the event isn't being the problem -- I just found it, and was like 'whut?'
[17:39] <DDR> No Problems Here. :)
[17:45] <DDR> KristaS: Actually, set(xy, zip([int] <- item.xy, cursor_offset, a+b)) needs the cast to [int], where item is object.


[16:56] <Jetrel_laptop> Sirp:  yeah, the next big one I'm tackling is a conversion where we're going to change up all of our levers on the various levels to a new mechanism...  basically we've had this persistence issue, so we're changing over to *mandating* that all gates and so on are always persistent.  They always require you to give them an event.
[16:57] <Jetrel_laptop> We did that for gates, already, prior to 1.3, and it solved a lot of issues.
[16:58] <Jetrel_laptop> So what we're now doing is we're going to switch the "lever" objects over to it as well.  The nice little benefit is this will mean they no longer need to be manually connected to the objects which they trigger.  Instead, they'll just do a quick map(filter(level.chars, value.event = me.event), fire_event(value, 'triggered'))
[17:03] <Jetrel_laptop> Should be good. :)


[17:47] <Jetrel> One quandary I have with this new lever system is, for example:
[17:48] <Jetrel> Fans and platforms - with platforms, it's quite less common, but with fans, it's fairly normal to want to have both "active" and "inactive" as default states prior to the player doing something that is later stored.
[17:48] <Jetrel> Ultimately, the purpose of fans is usually an obstruction, and unlike platforms, where moving almost always gives you new freedom, fans actually can achieve that both ways.
[17:49] <Jetrel> An off fan can need to be turned on to let you reach a high spot.  Or - an on fan can need to be turned off to let you run past it.
[17:50] <Jetrel> So whilst with platforms I've been able to always assume that state-changing ones should be off, and then get turned on, this isn't the case for fans.
[17:51] <Jetrel> ---
[17:51] <Jetrel> So we're trying to get away from having boolean flags in everything.
[17:52] <Jetrel> Since 1] doesn't persist across levels 2] raises some real confusion about precedence if you have boolean flags, and then separately have an event.
[17:53] <Jetrel> I think the way to do this is to have some object (unfortunately this needs to be "one and only one" - probably the lever that controls things), have an optional field for the default state of a certain event.
[17:55] <Jetrel> so if the level starts and the event hasn't been stored in the player set, it'll store this new state, and fire the toggle command to all involved parties...  this does however raise potential problems of walking onto a level, and having something odd happen like a gate suddenly closing.
[17:56] <Jetrel> Alternatively, we could have a list of such events right in frogatto itself - it's very clean to have them all globally listed, but it's nasty in that it breaks "locality of relevant information"
[17:57] <Jetrel> ... yuck, the last option is looking nicest. :(
[17:59] <Jetrel> :|  To be fair, "locality of relevant information" and "don't repeat yourself" are existentially opposed.
[18:01] <Jetrel> hmm
[18:02] <Jetrel> Let's give "in the lever" a try.
...
[18:04] <Jetrel> I have a bad feeling it may be hairy.  There's no way to enforce which order they get processed in, and if it sets the event before dependent items, we'll have to fire the toggle event at them.  (which is to say we always have to because we're blind about that).
...
[18:40] <DDR> Jetrel: Maybe just make the fan itself contain a boolean 'default_on' variable, which defaults to false? Then xor that with the stored event and all that would entail?
[18:40] <DDR> It would mean switches would be flipped with respect to what they did, but whatever. :P
[18:40] <Jetrel> DDR:  right, yeah, the goal is to avoid doing that.
[18:41] <DDR> Ah.
[18:41] <Jetrel> DDR:  the goal is to have these have *no* internal flag storing their value.  It's possible that's a stupid goal
[18:41] <Jetrel> DDR:  in fact...
[18:41] <Jetrel> DDR:  yeah - I think your plan is a much better plan. :)
[18:42] <DDR> It's a worthy goal, but not one that it's worth spending the amount of time that would need spending on it.


[15:14] <Sirp> DDR: you can't really check for the presence or absence of a property
[15:14] <Sirp> we might add a nice way to do this though
[15:15] <DDR> OK. I could add this property to pretty much *all* enemies... <--(NO WAY!!!)
[15:18] <Sirp> DDR: what you should be able to do is create an interface and see if the object matches the interface.
[15:18] <DDR> How do I define an interface, again?
if(value is {boss_hitpoints: decimal}, value.boss_hitpoints, value.hitpoints))
...
[18:43] <Sirp> DDR: so yeah basically there is no way to test "does this property exist in an object?" dynamically
[18:44] <Sirp> what I suggest is having a prototype which defines it and then see if the object is of the type of the prototype
[18:44] <DDR> Sirp: I sort of solved it. if(value is {boss_max_hitpoints: decimal}, value.boss_max_hitpoints, value.max_hitpoints))
[18:45] <DDR> Your tip about the interface was dead on.
[18:45] <DDR> (Uh, this isn't doing anything *nasty* under the hood, is it?)
[18:51] <DDR> Or, say, flat-out not working?
[18:52] <Sirp> DDR: yeah that won't work.
[18:52] <DDR> Curses.
[18:52] <Sirp> DDR: there is no real way to do it dynamically right now.


[18:58] <Jetrel> Essentially what all bosses that need to not be deleted after death SHOULD do, is they should let themselves properly go to zero hp...  then de-register themselves from the "gui's list of active bosses" (making the bar go away), and then give themselves back > 0 hitpoints.
[18:58] <Jetrel> This is what milgram does.
[18:59] * DDR nods.

!!!!!
[10:32] <Jetrel> DDR:  basically there's something broken afoot, where, now, if you try to query level.player for a stored event on the first frame of a level, it comes back null.
[10:40] <Jetrel> Sirp:  seems to be any property, but we've definitely had issues with the get_stored_event(name) property in "player_controlled" (the prototype frogatto inherits from, which is also declared as the player_type in module.cfg).
[10:42] <Sirp> note though that on_create is fired when the level starts and not all objects will be fully created at the point on_create is fired
[10:45] <Jetrel> Sirp:  that, and "on_start_level" get used to have things like gates check the player to determine if their initial state is open or closed, and they've all got special code to avoid visually showing a transition, and just to instantly "set themselves" to the mode that's specified.
[12:05] <Sirp> Jetrel: okay so the problem is the issue with on_create as I mentioned.
[12:05] <Sirp> but I'm thinking maybe we have to revert on_create to just the previous behavior
[12:05] <Sirp> but have a new on_init event
[12:05] <Sirp> which is used to actually initialize objects.
[12:06] <Sirp> and on_init will be different in that access must be quite limited. But can be used to construct initial state.
[12:07] <Sirp> the downside is this kind of proliferation of event types makes things complicated. :(
[12:10] <irker437> anura-engine: David White anura:master e4c57e2f77b7 / src/level.cpp: revert behavior of on_create http://git.io/XnppCA
[12:10] <Sirp> Jetrel: okay should be fixed now
[

[10:35] <DDR> It would just mean, in our case, that we wouldn't need to assign every lever-and-gate combination a variable in Frogatto.
[10:43] <Jetrel> DDR:  in theoretical terms, I agree with that fear, in practical terms, I refuse to change it because we've lived with that system for roughly two years now, and due to how I name events (by always strictly prefixing them with the level name), it will never cause problems.  I agree with what you're saying, but I don't want to overhaul a working system for no gain, especially when I just finished a marathon overhaul.  I also don't want someone else who doesn't have all the danger points just paged into their head, the hard way, do an overhaul.


