[17:55] <Jetrel> Sirp:  /Users/richard_kettering/Public/anura/src/formula.cpp:1128 ASSERTION FAILED: FUNCTION CALL ON EXPRESSION WHICH ISN'T GUARANTEED TO BE A FUNCTION: any AT At modules/frogatto/data/objects/enemies/experimental/gazer_grey.cfg 92:
[17:55] <Jetrel> _mdistort.stop_process(me),
[17:55] <Jetrel> ^-------------------------^
[17:55] <Jetrel> 	_mdistort: { type: "object", init: "construct('motion_distort')", persistent: false },
[17:55] <Jetrel> It's a library, but how can I "give it type" so that anura's aware of what's in it.
[01:28] <Sirp> Jetrel: do you mean that motion_distort is a class?
[01:28] <Sirp> Jetrel: you'd just make it of type class motion_distort
[01:28] <Sirp> if you're using it as a library I'm not sure why you need this _mdistort variable? Just use lib.motion_distort ? Or does it actually hold state?


[17:32] <DDR> Jetrel: OK, how do I initialize private properties from a spawn command? ASSERT FAIL: src/custom_object_functions.cpp:1209 ASSERTION FAILED: Illegal spawn of moth_small property _desired_height requires initialization
[17:33] <Jetrel> DDR:  uhm, you should be able to do them via a replacement for the 4th parameter.
[17:33] <DDR> OK.
[17:33] <Jetrel> Instead of facing, you'd have {_private_property:  foobar})
[17:33] <DDR> But I need that to set always_active.
[17:34] <Jetrel> Yeah, apparently there's some sort of support for kinda-sorta-but-not-really this in the 5th parameter as well.
[17:35] <DDR> It seems weird to specify a property as private and then have to access it.
[17:39] <Jetrel> DDR:  it can't be set(), is the thing.
[17:40] <Jetrel> Initialized?  sure.  Set at whenever time, no.
[17:42] <Sirp> yeah a private property can be initialized when you create the object
[17:42] <Sirp> I agree slightly weird. Just slightly
[17:42] <DDR> hahaha


[16:26] <DDR> "on_interact": "if( (not level.player.get_stored_event('moth_boss_fight_won')),
[16:26] <DDR>     [swallow_event(), level.player.scripted_move_to_x(988, 1, fire_event(me, 'script1'))]) asserting level.player is obj frogatto_playable",
[16:26] <DDR> Why doesn't that change the error message about the type of level.player not having scripted_move_to_x?
[16:26] <Jetrel_> I don't know - that's a Sirp question.
[16:27] <Jetrel_> That function is in player_controlled_platformer_character
[16:27] <Jetrel_> so it definitely should have it - check and see if the function is actually "for real" there, and not commented out or something.


[18:18] <DDR> Oh, *that* mdistort!
[18:18] <DDR> Uh, the ideal was that it would be a somewhat fire-and-forget way to add an axial motion distort to enemies.
[18:19] <DDR> Or, really, any objects.
[18:19] <Jetrel_> right, and didn't dave do some thing where you could store the associated variables for that within a library?
[18:19] <DDR> I think it's a lib. It's been a bit.
[18:20] <Jetrel_> okay, I'd like to polish that into a real unit.  If you could page in that knowledge that'd be cool.
[18:20] <DDR> Anyway, you instantiate a new version of the library, then I think you have to hook it in to a few places, and you're good to go.
[18:21] <DDR> it's in lib2d/data/classes/motion_distort.
[18:21] <DDR> The class itself is probably already strict.
[18:22] <DDR> Or almost strict?
[18:22] <Jetrel_> because I notice you're setting vars related to it, and it doesn't run right now.
[18:23] <Jetrel_> in the object, I mean
[18:23] <DDR> The way it *worked* was that you created a local copy for the object, then called process() to update the motion distort based on where the object was.
[18:24] <DDR> You could call stop_process if you wanted to remove the effect, say, if you wanted to use custom_draw for other things. It just zeros out the distortion matrix.
[18:25] <DDR> I had a brick on a test level set to do this, but I'd be highly surprised if it were still around.
[18:26] <DDR> test2.cfg
[18:28] <DDR> Jetrel:             on_create: "set(self.vars.mdistort, construct('motion_distort'))",
[18:28] <DDR>             on_process: "[
[18:28] <DDR>                 mdistort.process(me),
[18:28] <DDR>                 set(mid_xy, zip(level.player.ctrl_mice[0], level.camera_position[0:2], a+b)),
[18:28] <DDR>             ]",
[18:29] <DDR> That's test2.cfg, 167, btw, Jetrel.
[18:29] <Jetrel_> DDR:  construct has to be namespaced - where is it from?
[18:50] <Jetrel_> DDR:  again, I ask - what is "construct"?
[18:50] <Jetrel_> 	set(self.vars.mdistort, construct('motion_distort')),
[18:50] <DDR> Also, sorry, totally missed you the first time.
[18:50] <Jetrel_> I can't find it anywhere.
[18:50] <DDR> You have to "construct" a new edition of the library, so that the local variables don't get overwritten when you use the library a second time.
[18:51] <Jetrel_> DDR:  so that's a built-in, then?
[18:51] <DDR> Yeah.
[18:51] <Jetrel_> .... okay
[18:51] <DDR> The motion distortion library uses a few _private_variables, which need to be different for each object it's tracking.
[18:52] <DDR> Think of it like new whatever() in Javascript. A bit, at least.
[18:56] <DDR> Right. Just assign it to a storage-backed property, then?
[18:58] <Jetrel_> DDR:  ... okay.
https://github.com/frogatto/frogatto/commit/6aa43f68d6503dea461f22649963cdab6670698f


[15:51] <Jetrel_> Also, I'm finding that "map for the 4th parameter to object/spawn" to be really a nice convenience.


[19:14] <Jetrel> Sirp:  formula_function.cpp:3771 ASSERTION FAILED: Function call argument 4 does not match. Function expects bool provided string At modules/frogatto/data/objects/effects/control/text_controller.cfg 33:
[19:14] <Jetrel> text(txt, font, size, align)
[19:15] <Jetrel> Sirp:  align is a string of the set: ["left", "center", "right"] - not a bool.


[17:13] <Jetrel> Sirp:  is there a value one can query to tell if an object is attached to a level?
[17:15] <Sirp> Jetrel: no, you can just look for it in the level's list of objects
[17:15] <Jetrel> Okay.


[16:46] <Jetrel> Hmm, so I'm thinking the problem with the anthills is that because objects are no longer changing type, the stored references to the ants become hanging refs after they're swallowed.
[16:47] <Jetrel> Anthills are one of the few spawners that - rather than filtering level.chars for spawned mooks in a certain rectangular box, they instead add them to a list after spawning them.
[16:47] <Jetrel> So I expect it goes like:
[16:47] <Jetrel> 1] child spawned, ref added to anthill's list
[16:48] <Jetrel> 2] child swallowed.  Object removed by frogatto, but not deleted since the ref persists.
[16:49] <Jetrel> 3] frogatto replaces the child with a brand-new object..  but the brand-new object is no longer tracked by the anthill.  Instead the anthill is tracking the old object, which is now in limbo, no longer connected to the level.
[16:50] * Jetrel muses on this.


[12:30] <DDR> Jetrel: OK, so having given some thoughts to the basement-ant problem...
[12:31] <Jetrel> k
[12:31] <DDR> How in the world do we track if the ants have been killed?
[12:31] <Jetrel> A stored event, same as everything else.
[12:33] <DDR> Right, but how do I store the event?
[12:33] <Jetrel> level.player.store_event('foobar_happened', 1),  if memory serves
[12:34] <DDR> Well, yeah, that's the easy part.
[12:34] <Jetrel> yup
[12:34] <DDR> But how do I store the _event_ that that resides in?
[12:34] <Jetrel> You give the object an on_die:  "level.player.store_event('foobar_happened', 1)" event in the level.
[12:35] <Jetrel> Now, this is utterly broken by a change we've recently made:
[12:35] <DDR> Like, we don't store objects in Frogatto anymore, so if he kills the ants outside of the basement (or if he swallows them at all?) the object events are gone?
[12:35] <Jetrel> The moment frogatto even swallows the ant, the object events are gone.
[12:35] <Jetrel> This is a problem, and we need to figure out a general solution.
[12:35] * DDR nods
[12:36] <Jetrel> If there was a nice list of custom object events we could query, being able to query them and restore them would be pretty straightforward.
[12:36] <DDR> Yes.


[08:35] <Sirp> DDR / Jetrel_: okay so the problem when you go to the load door is just that the formula is rather messed up
[08:36] <Sirp> and strict mode is detecting the error
[08:40] <Sirp> DDR / Jetrel_: If you look in titlescreen.cfg, it goes set(child.event_handlers.enter_level, q( ...some formula... ))
[08:40] <Sirp> the issue is 'some formula' has strings that include ${...} expressions in them.
[08:40] <Sirp> the issue is that the ${...} expressions are going to get expanded at the time the outter q(...) string is parsed, NOT in the inner '...' string.
[08:41] <Sirp> and at the q(...) time, the identifiers they reference aren't valid.
[08:41] <Sirp> so, have to fix that. But then the q(...) formula is invalid in a number of other ways (mis-matched parens) and I can't immediately tell the intent to fix it.
[08:41] <Sirp> it might be good to have an FFL syntax for a 'literal' string though
[08:41] <Sirp> which doesn't do ${...} expansion
[09:05] <DDR> D'OH. xD
[09:05] <DDR> Sirp: What the formula is suppose to do, as far as I can tell, is set some text objects based on the properties of the saved levels.
[09:06] <DDR> It use to be in an event handler in menu_selector_load_level, but that object was horribly out-of-date compared to menu_selector.
[09:08] <DDR> The only difference that mattered, were two event handlers. Normally, this would go in the level file, and be a custom event of that object. But, here, since we have to create the object dynamically, we have to set the events in the level file that contains the object creating the menu_selector.
[09:13] <Sirp> DDR: beats me what it's meant to do
[09:14] <DDR> It's trying to spawn a few objects that tell you what the savegame you are loading is.
[09:14] <DDR> The second event actually loads the game.
[09:18] * Phanterm (~Karasawa@210.165.0.242) Quit
[09:19] <DDR> The way that selector works is that it reads some saved data and spawns the menu items based on that, and then when we select one the finish_menu event is fired.
[09:24] <DDR> Anyway, I removed the ${} interpolation.


[17:22] <DDR> Jetrel, do you know what the star in "on_mouse_down*" means?
[17:22] <Jetrel> No, that seems really.... odd
[17:33] <DDR> I bet it's to match even when the mouse event is outside the object too.
[17:34] <DDR> on_mouse_down -> click *on* object, on_mouse_down* -> click *anywhere*.
[17:34] <DDR> This menu thing is just opening up as a fractal of objects that need proper type handling.
[17:38] <KristaS> DDR: That is a correct interpretation. Though those events should already have type information specified for the args.* parameters
[17:39] <DDR> That's good. Yeah, the event isn't being the problem -- I just found it, and was like 'whut?'
[17:39] <DDR> No Problems Here. :)
[17:45] <DDR> KristaS: Actually, set(xy, zip([int] <- item.xy, cursor_offset, a+b)) needs the cast to [int], where item is object.


[16:56] <Jetrel_laptop> Sirp:  yeah, the next big one I'm tackling is a conversion where we're going to change up all of our levers on the various levels to a new mechanism...  basically we've had this persistence issue, so we're changing over to *mandating* that all gates and so on are always persistent.  They always require you to give them an event.
[16:57] <Jetrel_laptop> We did that for gates, already, prior to 1.3, and it solved a lot of issues.
[16:58] <Jetrel_laptop> So what we're now doing is we're going to switch the "lever" objects over to it as well.  The nice little benefit is this will mean they no longer need to be manually connected to the objects which they trigger.  Instead, they'll just do a quick map(filter(level.chars, value.event = me.event), fire_event(value, 'triggered'))
[17:03] <Jetrel_laptop> Should be good. :)


[17:47] <Jetrel> One quandary I have with this new lever system is, for example:
[17:48] <Jetrel> Fans and platforms - with platforms, it's quite less common, but with fans, it's fairly normal to want to have both "active" and "inactive" as default states prior to the player doing something that is later stored.
[17:48] <Jetrel> Ultimately, the purpose of fans is usually an obstruction, and unlike platforms, where moving almost always gives you new freedom, fans actually can achieve that both ways.
[17:49] <Jetrel> An off fan can need to be turned on to let you reach a high spot.  Or - an on fan can need to be turned off to let you run past it.
[17:50] <Jetrel> So whilst with platforms I've been able to always assume that state-changing ones should be off, and then get turned on, this isn't the case for fans.
[17:51] <Jetrel> ---
[17:51] <Jetrel> So we're trying to get away from having boolean flags in everything.
[17:52] <Jetrel> Since 1] doesn't persist across levels 2] raises some real confusion about precedence if you have boolean flags, and then separately have an event.
[17:53] <Jetrel> I think the way to do this is to have some object (unfortunately this needs to be "one and only one" - probably the lever that controls things), have an optional field for the default state of a certain event.
[17:55] <Jetrel> so if the level starts and the event hasn't been stored in the player set, it'll store this new state, and fire the toggle command to all involved parties...  this does however raise potential problems of walking onto a level, and having something odd happen like a gate suddenly closing.
[17:56] <Jetrel> Alternatively, we could have a list of such events right in frogatto itself - it's very clean to have them all globally listed, but it's nasty in that it breaks "locality of relevant information"
[17:57] <Jetrel> ... yuck, the last option is looking nicest. :(
[17:59] <Jetrel> :|  To be fair, "locality of relevant information" and "don't repeat yourself" are existentially opposed.
[18:01] <Jetrel> hmm
[18:02] <Jetrel> Let's give "in the lever" a try.
...
[18:04] <Jetrel> I have a bad feeling it may be hairy.  There's no way to enforce which order they get processed in, and if it sets the event before dependent items, we'll have to fire the toggle event at them.  (which is to say we always have to because we're blind about that).
...
[18:40] <DDR> Jetrel: Maybe just make the fan itself contain a boolean 'default_on' variable, which defaults to false? Then xor that with the stored event and all that would entail?
[18:40] <DDR> It would mean switches would be flipped with respect to what they did, but whatever. :P
[18:40] <Jetrel> DDR:  right, yeah, the goal is to avoid doing that.
[18:41] <DDR> Ah.
[18:41] <Jetrel> DDR:  the goal is to have these have *no* internal flag storing their value.  It's possible that's a stupid goal
[18:41] <Jetrel> DDR:  in fact...
[18:41] <Jetrel> DDR:  yeah - I think your plan is a much better plan. :)
[18:42] <DDR> It's a worthy goal, but not one that it's worth spending the amount of time that would need spending on it.


[15:14] <Sirp> DDR: you can't really check for the presence or absence of a property
[15:14] <Sirp> we might add a nice way to do this though
[15:15] <DDR> OK. I could add this property to pretty much *all* enemies... <--(NO WAY!!!)
[15:18] <Sirp> DDR: what you should be able to do is create an interface and see if the object matches the interface.
[15:18] <DDR> How do I define an interface, again?
if(value is {boss_hitpoints: decimal}, value.boss_hitpoints, value.hitpoints))
...
[18:43] <Sirp> DDR: so yeah basically there is no way to test "does this property exist in an object?" dynamically
[18:44] <Sirp> what I suggest is having a prototype which defines it and then see if the object is of the type of the prototype
[18:44] <DDR> Sirp: I sort of solved it. if(value is {boss_max_hitpoints: decimal}, value.boss_max_hitpoints, value.max_hitpoints))
[18:45] <DDR> Your tip about the interface was dead on.
[18:45] <DDR> (Uh, this isn't doing anything *nasty* under the hood, is it?)
[18:51] <DDR> Or, say, flat-out not working?
[18:52] <Sirp> DDR: yeah that won't work.
[18:52] <DDR> Curses.
[18:52] <Sirp> DDR: there is no real way to do it dynamically right now.


[18:58] <Jetrel> Essentially what all bosses that need to not be deleted after death SHOULD do, is they should let themselves properly go to zero hp...  then de-register themselves from the "gui's list of active bosses" (making the bar go away), and then give themselves back > 0 hitpoints.
[18:58] <Jetrel> This is what milgram does.
[18:59] * DDR nods.

!!!!!
[10:32] <Jetrel> DDR:  basically there's something broken afoot, where, now, if you try to query level.player for a stored event on the first frame of a level, it comes back null.
[10:40] <Jetrel> Sirp:  seems to be any property, but we've definitely had issues with the get_stored_event(name) property in "player_controlled" (the prototype frogatto inherits from, which is also declared as the player_type in module.cfg).
[10:42] <Sirp> note though that on_create is fired when the level starts and not all objects will be fully created at the point on_create is fired
[10:45] <Jetrel> Sirp:  that, and "on_start_level" get used to have things like gates check the player to determine if their initial state is open or closed, and they've all got special code to avoid visually showing a transition, and just to instantly "set themselves" to the mode that's specified.
[12:05] <Sirp> Jetrel: okay so the problem is the issue with on_create as I mentioned.
[12:05] <Sirp> but I'm thinking maybe we have to revert on_create to just the previous behavior
[12:05] <Sirp> but have a new on_init event
[12:05] <Sirp> which is used to actually initialize objects.
[12:06] <Sirp> and on_init will be different in that access must be quite limited. But can be used to construct initial state.
[12:07] <Sirp> the downside is this kind of proliferation of event types makes things complicated. :(
[12:10] <irker437> anura-engine: David White anura:master e4c57e2f77b7 / src/level.cpp: revert behavior of on_create http://git.io/XnppCA
[12:10] <Sirp> Jetrel: okay should be fixed now
[

[10:35] <DDR> It would just mean, in our case, that we wouldn't need to assign every lever-and-gate combination a variable in Frogatto.
[10:43] <Jetrel> DDR:  in theoretical terms, I agree with that fear, in practical terms, I refuse to change it because we've lived with that system for roughly two years now, and due to how I name events (by always strictly prefixing them with the level name), it will never cause problems.  I agree with what you're saying, but I don't want to overhaul a working system for no gain, especially when I just finished a marathon overhaul.  I also don't want someone else who doesn't have all the danger points just paged into their head, the hard way, do an overhaul.


